package infra

import (
	"errors"
	"fmt"
	"net/http"
	"os"
	"strconv"
	"time"

	"github.com/labstack/echo/v4"
)

const (
	// PAGESIZE number of document per page by default
	PAGESIZE   = 10
	swaggerURL = "/swagger/index.html"
)

var (
	ErrExtractToken = errors.New("extract token: error")
	ErrInvalidToken = errors.New("extract token: invalid token")
)

// redirectToSwag - for route from root / to swagger
func (s *Server) redirectToSwag(c echo.Context) error {
	return c.Redirect(http.StatusPermanentRedirect, swaggerURL)
}

// getPageParams parse http request parameters and returns offset and limit
func (s *Server) getPageParams(c echo.Context) (offset, limit int64) {

	slimit := c.QueryParam("limit")
	if slimit == "" {
		slimit = "0"
	}
	ilimit, err := strconv.Atoi(slimit)
	if err != nil {
		ilimit = PAGESIZE
	}
	if ilimit <= 0 {
		ilimit = PAGESIZE
	}

	soffset := c.QueryParam("offset")
	if soffset == "" {
		soffset = "0"
	}
	ioffset, err := strconv.Atoi(soffset)
	if err != nil {
		ioffset = 0
	}
	if ioffset <= 0 {
		ioffset = 0
	}
	limit, offset = int64(ilimit), int64(ioffset)
	return
}

// customHTTPLogger - middleware of logger and metric duration
func (s *Server) customHTTPLogger(next echo.HandlerFunc) echo.HandlerFunc {
	return func(c echo.Context) error {
		start := time.Now()
		if err := next(c); err != nil {
			c.Error(err)
		}
		rID := c.Response().Header().Get("x-request-id")
		code := c.Response().Status
		httplog := s.log.With(
			"method", c.Request().Method,
			"proto", c.Request().Proto,
			"remote", c.Request().RemoteAddr,
			"url", c.Request().RequestURI,
			"code", code,
			"size", c.Response().Size,
			"duration", time.Since(start).String(),
			requestIDName, rID)
		host, err := os.Hostname()
		if err != nil {
			host = "_localhost"
		}
		switch {
		case code < 300:
			httplog.Infof("%s", host)
		case code > 300 && code < 400:
			httplog.Warnf("%s", host)
		case code >= 400:
			httplog.Errorf("%s", host)
		}
		s.mAPI.WithLabelValues(c.Path(), strconv.Itoa(code)).Observe(float64(time.Since(start).Nanoseconds()))
		return nil
	}
}

// Generated by https://quicktype.io

type TokenPayload struct {
	AZP   string  `json:"azp"`
	Exp   float64 `json:"exp"`
	Name  string  `json:"name"`
	Email string  `json:"email"`
	Token string  `json:"token"`
}

// apiHealthCheck returk 200 ok if repository is connected
// @Summary healthcheck service eq repository connected
// @Tags health
// @Success 200 {object} infra.SuccessResponse
// @Failure 500 {object} infra.ErrResponse
// @Router /health [get]
func (s *Server) apiHealthCheck(c echo.Context) error {
	err := s.healthCheck()
	if err != nil {
		return c.JSON(http.StatusInternalServerError, ErrServerInternal(err))
	}
	return c.JSON(http.StatusOK, OkStatus("OK"))
}

// Metadata - metadata, page, limit, offset... etc...
type Metadata struct {
	ResultSet ResultSet `json:"result_set"`
}

// ResultSet - values total, limit....
type ResultSet struct {
	Count  int64 `json:"count"`
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
	Total  int64 `json:"total"`
}

// SuccessResponse structure for json response success results
type SuccessResponse struct {
	Message        string `json:"message"`  // text of message
	HTTPStatusCode int    `json:"httpcode"` // http response status code
	StatusText     string `json:"status"`   // user-level status message
}

// OkStatus wrapper HTTP 200 OK response
func OkStatus(message string) SuccessResponse {
	return SuccessResponse{
		Message:        message,
		HTTPStatusCode: http.StatusOK,
		StatusText:     http.StatusText(http.StatusOK),
	}
}

// CreatedStatus wrapper HTTP 201 Create response
func CreatedStatus(message string) SuccessResponse {
	return SuccessResponse{
		Message:        message,
		HTTPStatusCode: http.StatusCreated,
		StatusText:     http.StatusText(http.StatusCreated),
	}
}

// ErrResponse structure for common response with some error
type ErrResponse struct {
	Err            error `json:"-"` // low-level runtime error
	HTTPStatusCode int   `json:"-"` // http response status code

	StatusText string `json:"status"`          // user-level status message
	AppCode    int64  `json:"code,omitempty"`  // application-specific error code
	ErrorText  string `json:"error,omitempty"` // application-level error message, for debugging
}

// ErrInvalidRequest - wrapper for make err structure
func ErrInvalidRequest(err error) ErrResponse {
	return ErrResponse{
		Err:            err,
		HTTPStatusCode: http.StatusBadRequest,
		StatusText:     http.StatusText(http.StatusBadRequest),
		ErrorText:      fmt.Sprintf("%v", err),
	}
}

// ErrServerInternal - wrapper for make err structure
func ErrServerInternal(err error) ErrResponse {
	return ErrResponse{
		Err:            err,
		HTTPStatusCode: http.StatusInternalServerError,
		StatusText:     http.StatusText(http.StatusInternalServerError),
		ErrorText:      fmt.Sprintf("%v", err),
	}
}

// ErrNotFound - wrapper for make err structure for empty result
func ErrNotFound(err error) ErrResponse {
	Error := ""
	if err != nil {
		Error = err.Error()
	}
	return ErrResponse{
		Err:            err,
		HTTPStatusCode: http.StatusNotFound,
		StatusText:     http.StatusText(http.StatusNotFound),
		ErrorText:      Error,
	}
}

// ErrNotFound - wrapper for make err structure for empty result
func ErrUnAuthorized(err error) ErrResponse {
	Error := ""
	if err != nil {
		Error = err.Error()
	}
	return ErrResponse{
		Err:            err,
		HTTPStatusCode: http.StatusUnauthorized,
		StatusText:     http.StatusText(http.StatusUnauthorized),
		ErrorText:      Error,
	}
}

// ErrUnsupportedFormat - 415 error implementation
var ErrUnsupportedFormat = &ErrResponse{HTTPStatusCode: http.StatusUnsupportedMediaType,
	StatusText: "415 - Unsupported Media Type."}

// HTTPError represents an error that occurred while handling a request.
type HTTPError struct {
	Code     int         `json:"-"`
	Message  interface{} `json:"message"`
	Internal error       `json:"-"` // Stores the error returned by an external dependency
}
